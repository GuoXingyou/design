#effective java

###1.考虑用静态工厂方法代替构造器
####静态工厂方法类 vs. 构造器
#####优点：
> * 有名称
>   > 可读性高
> * 单例模式的运用
> * 可返回原返回类型的任何子类型对象 
>   > 可参考Java Collections Framework的集合接口实现,Collection Framework 
API相比导出32
个独立公有类来达到目的的实现方式要小得多，每一个被返回的对象都是被相关接口方法精确定义；同时使用这种静态工厂方法时，甚至要
求客户端通过接口来引用被返回的对象，而不是通过的他的实现类来引用
> * 创建泛型实例代码更加简洁，可参考guava中Lists中的方法
````
    //使用构造器创建
    Map<String, List<String>> m1 = new HashMap<String, List<String>>();
    //使用静态工厂方法创建
    Map<String, List<String>> m2 = HashMap.newInstance();
    
    public static <K, V> HashMap<K, V> newInstance() {
      return new HashMap<K, V>();
    }
````
> * 构成基于接口的框架，参考eg1代码，以服务提供者框架（Service Provider Framework）为例讲解，该框架的代表是JDBC API

[参考链接](http://www.jianshu.com/p/4d7a0cd36a82)
#####缺点：
> * 类如果不含有公有或受保护的构造器，就不能被子类化
> * 与其余静态方法实际上没有任何区别，在API文档中，它们没有像构造器那样被明确标识，因此对于提供静态工厂方法而没有构造器的类
来说，想要明确快速的找到如何实例化一个类很麻烦。所以，写好注释和标准的方法命名。 

***************************************************
###2.遇到多个构造器参数时考虑用构建器
> 无论是静态工厂还是构建器都有一个局限性，不能很好的扩建到大量的可选参数，我曾经遇到过通过构建器来进行约束的代码，过多的
入参导致代码整洁度和可读性不高；虽然对于有些场景可以使用重叠构造器，但是一旦参数增加，代码就会开始向着不可控的方向发展，
客户端代码也难以编写；另一种常见的javaBean模式，利用setter来避免入参错误，但是这会使得构造过程被分割，在构造过程可能出
现不一致，而且，JavaBean模式阻止了把类做成不可变的可能，就需要为他的线程安全额外付出
####Builder模式
* > builder模式保证了重叠构造器模式那样的安全性的同时也保证了JavaBean模式的可读性，不直接生成对象，让客户端调用必要的参数
构造一个builder对象，最后通过无参的build方法生成不可变对象，参考eg2代码。
* > builder模式也有自身不足，为了创建对象会先创建一个构建器，增加了开销，虽然实际中可能影响不大，但是某些需要性能的场景下可
能会带来问题。同时编写构建器比起重叠构造器更加冗长，IDEA搞的自动生成构造器的功能啊，excited！所以只有在参数较多的时候使用，
但是设计之初最好能考虑清楚，是否字段繁多，因为需要多个参数才添加构建器时，可能会使的代码无法控制，那些过时的构造器和静态工厂
就会显得不协调，所以我们创建类时一定要考虑历史的行程。
* > Generally speaking，如果类的构造器或者静态工厂中具有过多入参的时候，可以考虑Builder模式。

[参考链接](http://blog.csdn.net/h3c4lenovo/article/details/38687023)

***************************************************
###3.用私有构造器或者枚举类型强化Singleton属性
